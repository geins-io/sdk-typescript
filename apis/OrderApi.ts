/* tslint:disable */
/* eslint-disable */
/**
 * Geins Management API
 *  Geins Management API is an RESTful api to power your applications who manages your geins services. Geins provides an easy-to-use and scalable solution for managing all aspects of an online store, from product listings and customer information to order processing and payment transactions.   :::tip With this API, you can build custom applications and integrate with third-party systems, dashboards and other bussiness logic apps. :::    ## Getting started Once you have created an account, you can start using the Management API by creating an `API key`. You can create as many API keys as you need. Each `API key` is connected to a specific account so you can keep track of operations and manage keys. You can find your `API key` in the `geins merchant center`.   ### Fast track Use one of our [SDKs](https://docs.geins.io/docs/sdk/introduction) to get started quickly. The SDKs are available for the most popular programming languages and frameworks.  Or, if you prefer to just take it for a test run:  [![Run in Postman](https://run.pstmn.io/button.svg)](https://god.gw.postman.com/run-collection/25895885-aaf6598f-1a7c-4949-85d7-ba846c42d553?action=collection%2Ffork&collection-url=entityId%3D25895885-aaf6598f-1a7c-4949-85d7-ba846c42d553%26entityType%3Dcollection%26workspaceId%3Da2a179ce-158e-46b0-8d06-e9640f45112c)  ### Authentication Two authentication methods are supported:   - `API Key`   - `Basic Auth` 
 *
 * The version of the OpenAPI document: v1.7
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  APIOrderOrderComment,
  APIOrderTransactionData,
  EnvelopeInt,
  OrderCapture,
  OrderModelsOrder,
  OrderModelsOrderQuery,
  OrderModelsOrderStatus,
  OrderModelsOrderUpdate,
  OrderProcessedCapture,
  OrderProcessedRefund,
  OrderRefund,
  OrderValidateOrderCreationRequest,
} from '../models';
import {
    APIOrderOrderCommentFromJSON,
    APIOrderOrderCommentToJSON,
    APIOrderTransactionDataFromJSON,
    APIOrderTransactionDataToJSON,
    EnvelopeIntFromJSON,
    EnvelopeIntToJSON,
    OrderCaptureFromJSON,
    OrderCaptureToJSON,
    OrderModelsOrderFromJSON,
    OrderModelsOrderToJSON,
    OrderModelsOrderQueryFromJSON,
    OrderModelsOrderQueryToJSON,
    OrderModelsOrderStatusFromJSON,
    OrderModelsOrderStatusToJSON,
    OrderModelsOrderUpdateFromJSON,
    OrderModelsOrderUpdateToJSON,
    OrderProcessedCaptureFromJSON,
    OrderProcessedCaptureToJSON,
    OrderProcessedRefundFromJSON,
    OrderProcessedRefundToJSON,
    OrderRefundFromJSON,
    OrderRefundToJSON,
    OrderValidateOrderCreationRequestFromJSON,
    OrderValidateOrderCreationRequestToJSON,
} from '../models';

export interface AddCommentToOrderRequest {
    id: number;
    orderComment: APIOrderOrderComment;
}

export interface CreateOrderRequest {
    order: OrderModelsOrder;
}

export interface DeleteOrderRequest {
    id: number;
    operation: DeleteOrderOperationEnum;
}

export interface GetCaptureByIdRequest {
    captureId: string;
}

export interface GetOrderByIdRequest {
    id: number;
    include: string;
    combineProductContainerRows?: boolean;
}

export interface GetRefundByIdRequest {
    refundId: string;
}

export interface PartialUpdateOfOrderRequest {
    id: number;
    order: OrderModelsOrderUpdate;
}

export interface QueryOrdersRequest {
    query: OrderModelsOrderQuery;
}

export interface SetCaptureAsProcessedRequest {
    processedCapture: OrderProcessedCapture;
}

export interface SetPaymentAsPayedRequest {
    paymentDetailId: number;
}

export interface SetRefundAsProcessedRequest {
    processedRefund: OrderProcessedRefund;
}

export interface UpdateOrderStatusRequest {
    id: number;
    status: UpdateOrderStatusStatusEnum;
    transactionId: string;
    secondaryTransactionId: string;
}

export interface UpdateTransactionDataRequest {
    id: number;
    transactionData: APIOrderTransactionData;
}

export interface ValidateOrderRequest {
    request: OrderValidateOrderCreationRequest;
}

/**
 * 
 */
export class OrderApi extends runtime.BaseAPI {

    /**
     * This add to (not replace) any previous comments.
     * Adds a comment to the order
     */
    async addCommentToOrderRaw(requestParameters: AddCommentToOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling addCommentToOrder.');
        }

        if (requestParameters.orderComment === null || requestParameters.orderComment === undefined) {
            throw new runtime.RequiredError('orderComment','Required parameter requestParameters.orderComment was null or undefined when calling addCommentToOrder.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Order/{id}/Comment`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: APIOrderOrderCommentToJSON(requestParameters.orderComment),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * This add to (not replace) any previous comments.
     * Adds a comment to the order
     */
    async addCommentToOrder(requestParameters: AddCommentToOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.addCommentToOrderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Post a new order
     */
    async createOrderRaw(requestParameters: CreateOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvelopeInt>> {
        if (requestParameters.order === null || requestParameters.order === undefined) {
            throw new runtime.RequiredError('order','Required parameter requestParameters.order was null or undefined when calling createOrder.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Order`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OrderModelsOrderToJSON(requestParameters.order),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvelopeIntFromJSON(jsonValue));
    }

    /**
     * Post a new order
     */
    async createOrder(requestParameters: CreateOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvelopeInt> {
        const response = await this.createOrderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new order id
     */
    async createOrderIdRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvelopeInt>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Order/Id`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvelopeIntFromJSON(jsonValue));
    }

    /**
     * Create a new order id
     */
    async createOrderId(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvelopeInt> {
        const response = await this.createOrderIdRaw(initOverrides);
        return await response.value();
    }

    /**
     * Deletes or deactivates an order
     */
    async deleteOrderRaw(requestParameters: DeleteOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteOrder.');
        }

        if (requestParameters.operation === null || requestParameters.operation === undefined) {
            throw new runtime.RequiredError('operation','Required parameter requestParameters.operation was null or undefined when calling deleteOrder.');
        }

        const queryParameters: any = {};

        if (requestParameters.operation !== undefined) {
            queryParameters['operation'] = requestParameters.operation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Order/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Deletes or deactivates an order
     */
    async deleteOrder(requestParameters: DeleteOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.deleteOrderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Capture by Id
     */
    async getCaptureByIdRaw(requestParameters: GetCaptureByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OrderCapture>> {
        if (requestParameters.captureId === null || requestParameters.captureId === undefined) {
            throw new runtime.RequiredError('captureId','Required parameter requestParameters.captureId was null or undefined when calling getCaptureById.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Order/Capture/{captureId}`.replace(`{${"captureId"}}`, encodeURIComponent(String(requestParameters.captureId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OrderCaptureFromJSON(jsonValue));
    }

    /**
     * Get Capture by Id
     */
    async getCaptureById(requestParameters: GetCaptureByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OrderCapture> {
        const response = await this.getCaptureByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get an instance of a order
     */
    async getOrderByIdRaw(requestParameters: GetOrderByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OrderModelsOrder>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getOrderById.');
        }

        if (requestParameters.include === null || requestParameters.include === undefined) {
            throw new runtime.RequiredError('include','Required parameter requestParameters.include was null or undefined when calling getOrderById.');
        }

        const queryParameters: any = {};

        if (requestParameters.combineProductContainerRows !== undefined) {
            queryParameters['combineProductContainerRows'] = requestParameters.combineProductContainerRows;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Order/{id}/{include}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"include"}}`, encodeURIComponent(String(requestParameters.include))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OrderModelsOrderFromJSON(jsonValue));
    }

    /**
     * Get an instance of a order
     */
    async getOrderById(requestParameters: GetOrderByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OrderModelsOrder> {
        const response = await this.getOrderByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of available order statuses
     */
    async getOrderStatusesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<OrderModelsOrderStatus>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Order/Statuses`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(OrderModelsOrderStatusFromJSON));
    }

    /**
     * Get a list of available order statuses
     */
    async getOrderStatuses(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<OrderModelsOrderStatus>> {
        const response = await this.getOrderStatusesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get Refund by Id
     */
    async getRefundByIdRaw(requestParameters: GetRefundByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OrderRefund>> {
        if (requestParameters.refundId === null || requestParameters.refundId === undefined) {
            throw new runtime.RequiredError('refundId','Required parameter requestParameters.refundId was null or undefined when calling getRefundById.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Order/Refund/{refundId}`.replace(`{${"refundId"}}`, encodeURIComponent(String(requestParameters.refundId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OrderRefundFromJSON(jsonValue));
    }

    /**
     * Get Refund by Id
     */
    async getRefundById(requestParameters: GetRefundByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OrderRefund> {
        const response = await this.getRefundByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Partial update of an order
     */
    async partialUpdateOfOrderRaw(requestParameters: PartialUpdateOfOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling partialUpdateOfOrder.');
        }

        if (requestParameters.order === null || requestParameters.order === undefined) {
            throw new runtime.RequiredError('order','Required parameter requestParameters.order was null or undefined when calling partialUpdateOfOrder.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Order/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: OrderModelsOrderUpdateToJSON(requestParameters.order),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Partial update of an order
     */
    async partialUpdateOfOrder(requestParameters: PartialUpdateOfOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.partialUpdateOfOrderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Query the order repository
     */
    async queryOrdersRaw(requestParameters: QueryOrdersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<OrderModelsOrder>>> {
        if (requestParameters.query === null || requestParameters.query === undefined) {
            throw new runtime.RequiredError('query','Required parameter requestParameters.query was null or undefined when calling queryOrders.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Order/Query`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OrderModelsOrderQueryToJSON(requestParameters.query),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(OrderModelsOrderFromJSON));
    }

    /**
     * Query the order repository
     */
    async queryOrders(requestParameters: QueryOrdersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<OrderModelsOrder>> {
        const response = await this.queryOrdersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Set a capture as processed (= captured)
     */
    async setCaptureAsProcessedRaw(requestParameters: SetCaptureAsProcessedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.processedCapture === null || requestParameters.processedCapture === undefined) {
            throw new runtime.RequiredError('processedCapture','Required parameter requestParameters.processedCapture was null or undefined when calling setCaptureAsProcessed.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Order/Capture/SetAsProcessed`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OrderProcessedCaptureToJSON(requestParameters.processedCapture),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Set a capture as processed (= captured)
     */
    async setCaptureAsProcessed(requestParameters: SetCaptureAsProcessedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.setCaptureAsProcessedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Set Payment Detail as payed
     */
    async setPaymentAsPayedRaw(requestParameters: SetPaymentAsPayedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.paymentDetailId === null || requestParameters.paymentDetailId === undefined) {
            throw new runtime.RequiredError('paymentDetailId','Required parameter requestParameters.paymentDetailId was null or undefined when calling setPaymentAsPayed.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Order/PaymentDetail/{paymentDetailId}/SetAsPayed`.replace(`{${"paymentDetailId"}}`, encodeURIComponent(String(requestParameters.paymentDetailId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Set Payment Detail as payed
     */
    async setPaymentAsPayed(requestParameters: SetPaymentAsPayedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.setPaymentAsPayedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Set a refund as processed (= settled)
     */
    async setRefundAsProcessedRaw(requestParameters: SetRefundAsProcessedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.processedRefund === null || requestParameters.processedRefund === undefined) {
            throw new runtime.RequiredError('processedRefund','Required parameter requestParameters.processedRefund was null or undefined when calling setRefundAsProcessed.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Order/Refund/SetAsProcessed`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OrderProcessedRefundToJSON(requestParameters.processedRefund),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Set a refund as processed (= settled)
     */
    async setRefundAsProcessed(requestParameters: SetRefundAsProcessedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.setRefundAsProcessedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update order status
     */
    async updateOrderStatusRaw(requestParameters: UpdateOrderStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateOrderStatus.');
        }

        if (requestParameters.status === null || requestParameters.status === undefined) {
            throw new runtime.RequiredError('status','Required parameter requestParameters.status was null or undefined when calling updateOrderStatus.');
        }

        if (requestParameters.transactionId === null || requestParameters.transactionId === undefined) {
            throw new runtime.RequiredError('transactionId','Required parameter requestParameters.transactionId was null or undefined when calling updateOrderStatus.');
        }

        if (requestParameters.secondaryTransactionId === null || requestParameters.secondaryTransactionId === undefined) {
            throw new runtime.RequiredError('secondaryTransactionId','Required parameter requestParameters.secondaryTransactionId was null or undefined when calling updateOrderStatus.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Order/{id}/Status/{status}/{transactionId}/{secondaryTransactionId}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"status"}}`, encodeURIComponent(String(requestParameters.status))).replace(`{${"transactionId"}}`, encodeURIComponent(String(requestParameters.transactionId))).replace(`{${"secondaryTransactionId"}}`, encodeURIComponent(String(requestParameters.secondaryTransactionId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Update order status
     */
    async updateOrderStatus(requestParameters: UpdateOrderStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.updateOrderStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates transaction data on an order
     */
    async updateTransactionDataRaw(requestParameters: UpdateTransactionDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateTransactionData.');
        }

        if (requestParameters.transactionData === null || requestParameters.transactionData === undefined) {
            throw new runtime.RequiredError('transactionData','Required parameter requestParameters.transactionData was null or undefined when calling updateTransactionData.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Order/{id}/TransactionData`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: APIOrderTransactionDataToJSON(requestParameters.transactionData),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Updates transaction data on an order
     */
    async updateTransactionData(requestParameters: UpdateTransactionDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.updateTransactionDataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Validates order data for order creation.
     */
    async validateOrderRaw(requestParameters: ValidateOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling validateOrder.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Order/ValidateCreation`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OrderValidateOrderCreationRequestToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Validates order data for order creation.
     */
    async validateOrder(requestParameters: ValidateOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.validateOrderRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const DeleteOrderOperationEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;
export type DeleteOrderOperationEnum = typeof DeleteOrderOperationEnum[keyof typeof DeleteOrderOperationEnum];
/**
 * @export
 */
export const UpdateOrderStatusStatusEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6,
    NUMBER_7: 7
} as const;
export type UpdateOrderStatusStatusEnum = typeof UpdateOrderStatusStatusEnum[keyof typeof UpdateOrderStatusStatusEnum];
