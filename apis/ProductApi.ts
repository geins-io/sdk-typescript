/* tslint:disable */
/* eslint-disable */
/**
 * Geins Management API
 *  Geins Management API is an RESTful api to power your applications who manages your geins services. Geins provides an easy-to-use and scalable solution for managing all aspects of an online store, from product listings and customer information to order processing and payment transactions.   :::tip With this API, you can build custom applications and integrate with third-party systems, dashboards and other bussiness logic apps. :::    ## Getting started Once you have created an account, you can start using the Management API by creating an `API key`. You can create as many API keys as you need. Each `API key` is connected to a specific account so you can keep track of operations and manage keys. You can find your `API key` in the `geins merchant center`.   ### Fast track Use one of our [SDKs](https://docs.geins.io/docs/sdk/introduction) to get started quickly. The SDKs are available for the most popular programming languages and frameworks.  Or, if you prefer to just take it for a test run:  [![Run in Postman](https://run.pstmn.io/button.svg)](https://god.gw.postman.com/run-collection/25895885-aaf6598f-1a7c-4949-85d7-ba846c42d553?action=collection%2Ffork&collection-url=entityId%3D25895885-aaf6598f-1a7c-4949-85d7-ba846c42d553%26entityType%3Dcollection%26workspaceId%3Da2a179ce-158e-46b0-8d06-e9640f45112c)  ### Authentication Two authentication methods are supported:   - `API Key`   - `Basic Auth` 
 *
 * The version of the OpenAPI document: v1.7
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Envelope,
  EnvelopeListProductModelsReadFeed,
  EnvelopeListProductModelsReadProduct,
  EnvelopeListProductModelsReadProductItem,
  EnvelopeListProductModelsReadRelationType,
  EnvelopeProductModelsReadProduct,
  EnvelopeProductModelsReadProductItem,
  ProductModelsMonitorSku,
  ProductModelsProductCategory,
  ProductModelsProductQuery,
  ProductModelsReadProductItem,
  ProductModelsReadProductItemStock,
  ProductModelsRelatedProductEnvelope,
  ProductModelsStockEnvelope,
  ProductModelsWriteProduct,
  ProductModelsWriteProductItem,
  ProductModelsWriteProductItemStock,
  ProductModelsWriteRelatedProduct,
  ProductProductItemEnvelope,
} from '../models';
import {
    EnvelopeFromJSON,
    EnvelopeToJSON,
    EnvelopeListProductModelsReadFeedFromJSON,
    EnvelopeListProductModelsReadFeedToJSON,
    EnvelopeListProductModelsReadProductFromJSON,
    EnvelopeListProductModelsReadProductToJSON,
    EnvelopeListProductModelsReadProductItemFromJSON,
    EnvelopeListProductModelsReadProductItemToJSON,
    EnvelopeListProductModelsReadRelationTypeFromJSON,
    EnvelopeListProductModelsReadRelationTypeToJSON,
    EnvelopeProductModelsReadProductFromJSON,
    EnvelopeProductModelsReadProductToJSON,
    EnvelopeProductModelsReadProductItemFromJSON,
    EnvelopeProductModelsReadProductItemToJSON,
    ProductModelsMonitorSkuFromJSON,
    ProductModelsMonitorSkuToJSON,
    ProductModelsProductCategoryFromJSON,
    ProductModelsProductCategoryToJSON,
    ProductModelsProductQueryFromJSON,
    ProductModelsProductQueryToJSON,
    ProductModelsReadProductItemFromJSON,
    ProductModelsReadProductItemToJSON,
    ProductModelsReadProductItemStockFromJSON,
    ProductModelsReadProductItemStockToJSON,
    ProductModelsRelatedProductEnvelopeFromJSON,
    ProductModelsRelatedProductEnvelopeToJSON,
    ProductModelsStockEnvelopeFromJSON,
    ProductModelsStockEnvelopeToJSON,
    ProductModelsWriteProductFromJSON,
    ProductModelsWriteProductToJSON,
    ProductModelsWriteProductItemFromJSON,
    ProductModelsWriteProductItemToJSON,
    ProductModelsWriteProductItemStockFromJSON,
    ProductModelsWriteProductItemStockToJSON,
    ProductModelsWriteRelatedProductFromJSON,
    ProductModelsWriteRelatedProductToJSON,
    ProductProductItemEnvelopeFromJSON,
    ProductProductItemEnvelopeToJSON,
} from '../models';

export interface AddAvailabilityMonitorRequest {
    model: ProductModelsMonitorSku;
}

export interface AddCategoryToProductRequest {
    productId: string;
    productCategory: ProductModelsProductCategory;
    productIdType?: AddCategoryToProductProductIdTypeEnum;
}

export interface AddImageToProductRequest {
    productId: string;
    imageName: string;
    isPrimaryImage?: boolean;
    productIdType?: AddImageToProductProductIdTypeEnum;
}

export interface AddRelatedProductsToProductRequest {
    productId: string;
    relatedProducts: Array<ProductModelsWriteRelatedProduct>;
    productIdType?: AddRelatedProductsToProductProductIdTypeEnum;
}

export interface BatchUpdateProductItemsRequest {
    productItems: Array<ProductModelsWriteProductItem>;
    productItemIdType?: BatchUpdateProductItemsProductItemIdTypeEnum;
}

export interface BatchUpdateStockValuesRequest {
    productItemStocks: Array<ProductModelsWriteProductItemStock>;
    productItemIdType?: BatchUpdateStockValuesProductItemIdTypeEnum;
}

export interface CreateProductRequest {
    product: ProductModelsWriteProduct;
    include?: string;
}

export interface CreateProductItemsRequest {
    productId: string;
    productItem: ProductModelsWriteProductItem;
    productIdType?: CreateProductItemsProductIdTypeEnum;
}

export interface GetProductByIdRequest {
    productId: string;
    productIdType?: GetProductByIdProductIdTypeEnum;
    include?: string;
}

export interface GetProductItemByIdRequest {
    itemId: string;
    productItemIdType?: GetProductItemByIdProductItemIdTypeEnum;
}

export interface LinkRelatedProductsByRelationIdRequest {
    productId: string;
    relationTypeId: number;
    relatedProducts: Array<ProductModelsWriteRelatedProduct>;
    productIdType?: LinkRelatedProductsByRelationIdProductIdTypeEnum;
}

export interface ListAllProductItemsPagedRequest {
    page: number;
}

export interface QueryProductsRequest {
    query: ProductModelsProductQuery;
    include?: string;
}

export interface QueryProductsPagedRequest {
    page: number;
    query: ProductModelsProductQuery;
    include?: string;
}

export interface QueryStockRequest {
    productItemIds: Array<number>;
}

export interface UpdateProductRequest {
    productId: string;
    product: ProductModelsWriteProduct;
    productIdType?: UpdateProductProductIdTypeEnum;
    include?: string;
}

export interface UpdateProductItemRequest {
    itemId: string;
    productItem: ProductModelsWriteProductItem;
    productItemIdType?: UpdateProductItemProductItemIdTypeEnum;
}

/**
 * 
 */
export class ProductApi extends runtime.BaseAPI {

    /**
     * Add a product availability monitor
     */
    async addAvailabilityMonitorRaw(requestParameters: AddAvailabilityMonitorRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Envelope>> {
        if (requestParameters.model === null || requestParameters.model === undefined) {
            throw new runtime.RequiredError('model','Required parameter requestParameters.model was null or undefined when calling addAvailabilityMonitor.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/MonitorAvailability`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProductModelsMonitorSkuToJSON(requestParameters.model),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvelopeFromJSON(jsonValue));
    }

    /**
     * Add a product availability monitor
     */
    async addAvailabilityMonitor(requestParameters: AddAvailabilityMonitorRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Envelope> {
        const response = await this.addAvailabilityMonitorRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Adds a category relation to a product
     */
    async addCategoryToProductRaw(requestParameters: AddCategoryToProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Envelope>> {
        if (requestParameters.productId === null || requestParameters.productId === undefined) {
            throw new runtime.RequiredError('productId','Required parameter requestParameters.productId was null or undefined when calling addCategoryToProduct.');
        }

        if (requestParameters.productCategory === null || requestParameters.productCategory === undefined) {
            throw new runtime.RequiredError('productCategory','Required parameter requestParameters.productCategory was null or undefined when calling addCategoryToProduct.');
        }

        const queryParameters: any = {};

        if (requestParameters.productIdType !== undefined) {
            queryParameters['productIdType'] = requestParameters.productIdType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/{productId}/Category`.replace(`{${"productId"}}`, encodeURIComponent(String(requestParameters.productId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ProductModelsProductCategoryToJSON(requestParameters.productCategory),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvelopeFromJSON(jsonValue));
    }

    /**
     * Adds a category relation to a product
     */
    async addCategoryToProduct(requestParameters: AddCategoryToProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Envelope> {
        const response = await this.addCategoryToProductRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Adds an image relation to a product
     */
    async addImageToProductRaw(requestParameters: AddImageToProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Envelope>> {
        if (requestParameters.productId === null || requestParameters.productId === undefined) {
            throw new runtime.RequiredError('productId','Required parameter requestParameters.productId was null or undefined when calling addImageToProduct.');
        }

        if (requestParameters.imageName === null || requestParameters.imageName === undefined) {
            throw new runtime.RequiredError('imageName','Required parameter requestParameters.imageName was null or undefined when calling addImageToProduct.');
        }

        const queryParameters: any = {};

        if (requestParameters.isPrimaryImage !== undefined) {
            queryParameters['isPrimaryImage'] = requestParameters.isPrimaryImage;
        }

        if (requestParameters.productIdType !== undefined) {
            queryParameters['productIdType'] = requestParameters.productIdType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/{productId}/Image/{imageName}`.replace(`{${"productId"}}`, encodeURIComponent(String(requestParameters.productId))).replace(`{${"imageName"}}`, encodeURIComponent(String(requestParameters.imageName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvelopeFromJSON(jsonValue));
    }

    /**
     * Adds an image relation to a product
     */
    async addImageToProduct(requestParameters: AddImageToProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Envelope> {
        const response = await this.addImageToProductRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add related products to a product
     */
    async addRelatedProductsToProductRaw(requestParameters: AddRelatedProductsToProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProductModelsRelatedProductEnvelope>> {
        if (requestParameters.productId === null || requestParameters.productId === undefined) {
            throw new runtime.RequiredError('productId','Required parameter requestParameters.productId was null or undefined when calling addRelatedProductsToProduct.');
        }

        if (requestParameters.relatedProducts === null || requestParameters.relatedProducts === undefined) {
            throw new runtime.RequiredError('relatedProducts','Required parameter requestParameters.relatedProducts was null or undefined when calling addRelatedProductsToProduct.');
        }

        const queryParameters: any = {};

        if (requestParameters.productIdType !== undefined) {
            queryParameters['productIdType'] = requestParameters.productIdType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/{productId}/Related`.replace(`{${"productId"}}`, encodeURIComponent(String(requestParameters.productId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.relatedProducts.map(ProductModelsWriteRelatedProductToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProductModelsRelatedProductEnvelopeFromJSON(jsonValue));
    }

    /**
     * Add related products to a product
     */
    async addRelatedProductsToProduct(requestParameters: AddRelatedProductsToProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProductModelsRelatedProductEnvelope> {
        const response = await this.addRelatedProductsToProductRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates product items in batch
     */
    async batchUpdateProductItemsRaw(requestParameters: BatchUpdateProductItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Envelope>> {
        if (requestParameters.productItems === null || requestParameters.productItems === undefined) {
            throw new runtime.RequiredError('productItems','Required parameter requestParameters.productItems was null or undefined when calling batchUpdateProductItems.');
        }

        const queryParameters: any = {};

        if (requestParameters.productItemIdType !== undefined) {
            queryParameters['productItemIdType'] = requestParameters.productItemIdType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/Items`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.productItems.map(ProductModelsWriteProductItemToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvelopeFromJSON(jsonValue));
    }

    /**
     * Updates product items in batch
     */
    async batchUpdateProductItems(requestParameters: BatchUpdateProductItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Envelope> {
        const response = await this.batchUpdateProductItemsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update stock values for multiple product items
     */
    async batchUpdateStockValuesRaw(requestParameters: BatchUpdateStockValuesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProductModelsStockEnvelope>> {
        if (requestParameters.productItemStocks === null || requestParameters.productItemStocks === undefined) {
            throw new runtime.RequiredError('productItemStocks','Required parameter requestParameters.productItemStocks was null or undefined when calling batchUpdateStockValues.');
        }

        const queryParameters: any = {};

        if (requestParameters.productItemIdType !== undefined) {
            queryParameters['productItemIdType'] = requestParameters.productItemIdType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/Stock`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.productItemStocks.map(ProductModelsWriteProductItemStockToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProductModelsStockEnvelopeFromJSON(jsonValue));
    }

    /**
     * Update stock values for multiple product items
     */
    async batchUpdateStockValues(requestParameters: BatchUpdateStockValuesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProductModelsStockEnvelope> {
        const response = await this.batchUpdateStockValuesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new product
     */
    async createProductRaw(requestParameters: CreateProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvelopeProductModelsReadProduct>> {
        if (requestParameters.product === null || requestParameters.product === undefined) {
            throw new runtime.RequiredError('product','Required parameter requestParameters.product was null or undefined when calling createProduct.');
        }

        const queryParameters: any = {};

        if (requestParameters.include !== undefined) {
            queryParameters['include'] = requestParameters.include;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProductModelsWriteProductToJSON(requestParameters.product),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvelopeProductModelsReadProductFromJSON(jsonValue));
    }

    /**
     * Create a new product
     */
    async createProduct(requestParameters: CreateProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvelopeProductModelsReadProduct> {
        const response = await this.createProductRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new product item
     */
    async createProductItemsRaw(requestParameters: CreateProductItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvelopeProductModelsReadProductItem>> {
        if (requestParameters.productId === null || requestParameters.productId === undefined) {
            throw new runtime.RequiredError('productId','Required parameter requestParameters.productId was null or undefined when calling createProductItems.');
        }

        if (requestParameters.productItem === null || requestParameters.productItem === undefined) {
            throw new runtime.RequiredError('productItem','Required parameter requestParameters.productItem was null or undefined when calling createProductItems.');
        }

        const queryParameters: any = {};

        if (requestParameters.productIdType !== undefined) {
            queryParameters['productIdType'] = requestParameters.productIdType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/{productId}/Item`.replace(`{${"productId"}}`, encodeURIComponent(String(requestParameters.productId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProductModelsWriteProductItemToJSON(requestParameters.productItem),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvelopeProductModelsReadProductItemFromJSON(jsonValue));
    }

    /**
     * Create a new product item
     */
    async createProductItems(requestParameters: CreateProductItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvelopeProductModelsReadProductItem> {
        const response = await this.createProductItemsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a specific product
     */
    async getProductByIdRaw(requestParameters: GetProductByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvelopeProductModelsReadProduct>> {
        if (requestParameters.productId === null || requestParameters.productId === undefined) {
            throw new runtime.RequiredError('productId','Required parameter requestParameters.productId was null or undefined when calling getProductById.');
        }

        const queryParameters: any = {};

        if (requestParameters.productIdType !== undefined) {
            queryParameters['productIdType'] = requestParameters.productIdType;
        }

        if (requestParameters.include !== undefined) {
            queryParameters['include'] = requestParameters.include;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/{productId}`.replace(`{${"productId"}}`, encodeURIComponent(String(requestParameters.productId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvelopeProductModelsReadProductFromJSON(jsonValue));
    }

    /**
     * Get a specific product
     */
    async getProductById(requestParameters: GetProductByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvelopeProductModelsReadProduct> {
        const response = await this.getProductByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a specific product item
     */
    async getProductItemByIdRaw(requestParameters: GetProductItemByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProductProductItemEnvelope>> {
        if (requestParameters.itemId === null || requestParameters.itemId === undefined) {
            throw new runtime.RequiredError('itemId','Required parameter requestParameters.itemId was null or undefined when calling getProductItemById.');
        }

        const queryParameters: any = {};

        if (requestParameters.productItemIdType !== undefined) {
            queryParameters['productItemIdType'] = requestParameters.productItemIdType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/Item/{itemId}`.replace(`{${"itemId"}}`, encodeURIComponent(String(requestParameters.itemId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProductProductItemEnvelopeFromJSON(jsonValue));
    }

    /**
     * Get a specific product item
     */
    async getProductItemById(requestParameters: GetProductItemByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProductProductItemEnvelope> {
        const response = await this.getProductItemByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add related products to a product using a fixed relation type
     */
    async linkRelatedProductsByRelationIdRaw(requestParameters: LinkRelatedProductsByRelationIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProductModelsRelatedProductEnvelope>> {
        if (requestParameters.productId === null || requestParameters.productId === undefined) {
            throw new runtime.RequiredError('productId','Required parameter requestParameters.productId was null or undefined when calling linkRelatedProductsByRelationId.');
        }

        if (requestParameters.relationTypeId === null || requestParameters.relationTypeId === undefined) {
            throw new runtime.RequiredError('relationTypeId','Required parameter requestParameters.relationTypeId was null or undefined when calling linkRelatedProductsByRelationId.');
        }

        if (requestParameters.relatedProducts === null || requestParameters.relatedProducts === undefined) {
            throw new runtime.RequiredError('relatedProducts','Required parameter requestParameters.relatedProducts was null or undefined when calling linkRelatedProductsByRelationId.');
        }

        const queryParameters: any = {};

        if (requestParameters.productIdType !== undefined) {
            queryParameters['productIdType'] = requestParameters.productIdType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/{productId}/Related/{relationTypeId}`.replace(`{${"productId"}}`, encodeURIComponent(String(requestParameters.productId))).replace(`{${"relationTypeId"}}`, encodeURIComponent(String(requestParameters.relationTypeId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.relatedProducts.map(ProductModelsWriteRelatedProductToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProductModelsRelatedProductEnvelopeFromJSON(jsonValue));
    }

    /**
     * Add related products to a product using a fixed relation type
     */
    async linkRelatedProductsByRelationId(requestParameters: LinkRelatedProductsByRelationIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProductModelsRelatedProductEnvelope> {
        const response = await this.linkRelatedProductsByRelationIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all product items with pagination
     */
    async listAllProductItemsPagedRaw(requestParameters: ListAllProductItemsPagedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvelopeListProductModelsReadProductItem>> {
        if (requestParameters.page === null || requestParameters.page === undefined) {
            throw new runtime.RequiredError('page','Required parameter requestParameters.page was null or undefined when calling listAllProductItemsPaged.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/Items/{page}`.replace(`{${"page"}}`, encodeURIComponent(String(requestParameters.page))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvelopeListProductModelsReadProductItemFromJSON(jsonValue));
    }

    /**
     * Get all product items with pagination
     */
    async listAllProductItemsPaged(requestParameters: ListAllProductItemsPagedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvelopeListProductModelsReadProductItem> {
        const response = await this.listAllProductItemsPagedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets a list of all feeds
     */
    async listFeedsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvelopeListProductModelsReadFeed>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/Feeds`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvelopeListProductModelsReadFeedFromJSON(jsonValue));
    }

    /**
     * Gets a list of all feeds
     */
    async listFeeds(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvelopeListProductModelsReadFeed> {
        const response = await this.listFeedsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get all product items
     */
    async listProductItemsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ProductModelsReadProductItem>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/Items`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ProductModelsReadProductItemFromJSON));
    }

    /**
     * Get all product items
     */
    async listProductItems(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ProductModelsReadProductItem>> {
        const response = await this.listProductItemsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Gets a list of product relation types
     */
    async listProductRelationTypesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvelopeListProductModelsReadRelationType>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/RelationTypes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvelopeListProductModelsReadRelationTypeFromJSON(jsonValue));
    }

    /**
     * Gets a list of product relation types
     */
    async listProductRelationTypes(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvelopeListProductModelsReadRelationType> {
        const response = await this.listProductRelationTypesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Query products
     */
    async queryProductsRaw(requestParameters: QueryProductsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvelopeListProductModelsReadProduct>> {
        if (requestParameters.query === null || requestParameters.query === undefined) {
            throw new runtime.RequiredError('query','Required parameter requestParameters.query was null or undefined when calling queryProducts.');
        }

        const queryParameters: any = {};

        if (requestParameters.include !== undefined) {
            queryParameters['include'] = requestParameters.include;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/Query`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProductModelsProductQueryToJSON(requestParameters.query),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvelopeListProductModelsReadProductFromJSON(jsonValue));
    }

    /**
     * Query products
     */
    async queryProducts(requestParameters: QueryProductsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvelopeListProductModelsReadProduct> {
        const response = await this.queryProductsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * The {Product.Models.ProductQuery.BatchId} property is mandatory when fetching a page other than the first page.  If no BatchId is provided for the first page, a new batch is created and the BatchId can be found in the {Envelope.PageResult} field.
     * Query products with pagination
     */
    async queryProductsPagedRaw(requestParameters: QueryProductsPagedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvelopeListProductModelsReadProduct>> {
        if (requestParameters.page === null || requestParameters.page === undefined) {
            throw new runtime.RequiredError('page','Required parameter requestParameters.page was null or undefined when calling queryProductsPaged.');
        }

        if (requestParameters.query === null || requestParameters.query === undefined) {
            throw new runtime.RequiredError('query','Required parameter requestParameters.query was null or undefined when calling queryProductsPaged.');
        }

        const queryParameters: any = {};

        if (requestParameters.include !== undefined) {
            queryParameters['include'] = requestParameters.include;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/Query/{page}`.replace(`{${"page"}}`, encodeURIComponent(String(requestParameters.page))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProductModelsProductQueryToJSON(requestParameters.query),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvelopeListProductModelsReadProductFromJSON(jsonValue));
    }

    /**
     * The {Product.Models.ProductQuery.BatchId} property is mandatory when fetching a page other than the first page.  If no BatchId is provided for the first page, a new batch is created and the BatchId can be found in the {Envelope.PageResult} field.
     * Query products with pagination
     */
    async queryProductsPaged(requestParameters: QueryProductsPagedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvelopeListProductModelsReadProduct> {
        const response = await this.queryProductsPagedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Query stock
     */
    async queryStockRaw(requestParameters: QueryStockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ProductModelsReadProductItemStock>>> {
        if (requestParameters.productItemIds === null || requestParameters.productItemIds === undefined) {
            throw new runtime.RequiredError('productItemIds','Required parameter requestParameters.productItemIds was null or undefined when calling queryStock.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/Stock/Query`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.productItemIds,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ProductModelsReadProductItemStockFromJSON));
    }

    /**
     * Query stock
     */
    async queryStock(requestParameters: QueryStockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ProductModelsReadProductItemStock>> {
        const response = await this.queryStockRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a product
     */
    async updateProductRaw(requestParameters: UpdateProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvelopeProductModelsReadProduct>> {
        if (requestParameters.productId === null || requestParameters.productId === undefined) {
            throw new runtime.RequiredError('productId','Required parameter requestParameters.productId was null or undefined when calling updateProduct.');
        }

        if (requestParameters.product === null || requestParameters.product === undefined) {
            throw new runtime.RequiredError('product','Required parameter requestParameters.product was null or undefined when calling updateProduct.');
        }

        const queryParameters: any = {};

        if (requestParameters.productIdType !== undefined) {
            queryParameters['productIdType'] = requestParameters.productIdType;
        }

        if (requestParameters.include !== undefined) {
            queryParameters['include'] = requestParameters.include;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/{productId}`.replace(`{${"productId"}}`, encodeURIComponent(String(requestParameters.productId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ProductModelsWriteProductToJSON(requestParameters.product),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvelopeProductModelsReadProductFromJSON(jsonValue));
    }

    /**
     * Updates a product
     */
    async updateProduct(requestParameters: UpdateProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvelopeProductModelsReadProduct> {
        const response = await this.updateProductRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a product item
     */
    async updateProductItemRaw(requestParameters: UpdateProductItemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvelopeProductModelsReadProductItem>> {
        if (requestParameters.itemId === null || requestParameters.itemId === undefined) {
            throw new runtime.RequiredError('itemId','Required parameter requestParameters.itemId was null or undefined when calling updateProductItem.');
        }

        if (requestParameters.productItem === null || requestParameters.productItem === undefined) {
            throw new runtime.RequiredError('productItem','Required parameter requestParameters.productItem was null or undefined when calling updateProductItem.');
        }

        const queryParameters: any = {};

        if (requestParameters.productItemIdType !== undefined) {
            queryParameters['productItemIdType'] = requestParameters.productItemIdType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-apikey"] = this.configuration.apiKey("x-apikey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/Item/{itemId}`.replace(`{${"itemId"}}`, encodeURIComponent(String(requestParameters.itemId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ProductModelsWriteProductItemToJSON(requestParameters.productItem),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvelopeProductModelsReadProductItemFromJSON(jsonValue));
    }

    /**
     * Updates a product item
     */
    async updateProductItem(requestParameters: UpdateProductItemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvelopeProductModelsReadProductItem> {
        const response = await this.updateProductItemRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const AddCategoryToProductProductIdTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;
export type AddCategoryToProductProductIdTypeEnum = typeof AddCategoryToProductProductIdTypeEnum[keyof typeof AddCategoryToProductProductIdTypeEnum];
/**
 * @export
 */
export const AddImageToProductProductIdTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;
export type AddImageToProductProductIdTypeEnum = typeof AddImageToProductProductIdTypeEnum[keyof typeof AddImageToProductProductIdTypeEnum];
/**
 * @export
 */
export const AddRelatedProductsToProductProductIdTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;
export type AddRelatedProductsToProductProductIdTypeEnum = typeof AddRelatedProductsToProductProductIdTypeEnum[keyof typeof AddRelatedProductsToProductProductIdTypeEnum];
/**
 * @export
 */
export const BatchUpdateProductItemsProductItemIdTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;
export type BatchUpdateProductItemsProductItemIdTypeEnum = typeof BatchUpdateProductItemsProductItemIdTypeEnum[keyof typeof BatchUpdateProductItemsProductItemIdTypeEnum];
/**
 * @export
 */
export const BatchUpdateStockValuesProductItemIdTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;
export type BatchUpdateStockValuesProductItemIdTypeEnum = typeof BatchUpdateStockValuesProductItemIdTypeEnum[keyof typeof BatchUpdateStockValuesProductItemIdTypeEnum];
/**
 * @export
 */
export const CreateProductItemsProductIdTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;
export type CreateProductItemsProductIdTypeEnum = typeof CreateProductItemsProductIdTypeEnum[keyof typeof CreateProductItemsProductIdTypeEnum];
/**
 * @export
 */
export const GetProductByIdProductIdTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;
export type GetProductByIdProductIdTypeEnum = typeof GetProductByIdProductIdTypeEnum[keyof typeof GetProductByIdProductIdTypeEnum];
/**
 * @export
 */
export const GetProductItemByIdProductItemIdTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;
export type GetProductItemByIdProductItemIdTypeEnum = typeof GetProductItemByIdProductItemIdTypeEnum[keyof typeof GetProductItemByIdProductItemIdTypeEnum];
/**
 * @export
 */
export const LinkRelatedProductsByRelationIdProductIdTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;
export type LinkRelatedProductsByRelationIdProductIdTypeEnum = typeof LinkRelatedProductsByRelationIdProductIdTypeEnum[keyof typeof LinkRelatedProductsByRelationIdProductIdTypeEnum];
/**
 * @export
 */
export const UpdateProductProductIdTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;
export type UpdateProductProductIdTypeEnum = typeof UpdateProductProductIdTypeEnum[keyof typeof UpdateProductProductIdTypeEnum];
/**
 * @export
 */
export const UpdateProductItemProductItemIdTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;
export type UpdateProductItemProductItemIdTypeEnum = typeof UpdateProductItemProductItemIdTypeEnum[keyof typeof UpdateProductItemProductItemIdTypeEnum];
